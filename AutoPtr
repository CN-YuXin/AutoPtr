#include <_TestVersion>

#if !defined(_AUTO_PTR_OF_YX_) && _CPP_VERSION_ != 98
#define _AUTO_PTR_OF_YX_

#include <type_traits>
#include <stddef.h>

#ifdef STD_NAMESPACE
namespace STD_NAMESPACE {
#endif

template <typename U>
struct Delete {
	void operator()(U* d) {
		delete d;
	}
};
template <typename U, size_t S>
struct Delete<U[S]> {
	void operator()(U(*d)[S]) {
		delete [] d;
	}
};
#if _CPP_VERSION_ >= 17
template <typename T, template <typename> typename D = Delete>
#else
template <typename T, typename D = Delete<T>>
#endif
class AutoPtr {
  public:
	#if _CPP_VERSION_ >= 17
	using deleteClass = D<T>;
	#else
	using deleteClass = D;
	#endif
	using pointToType = T;
	using elementType = typename std::remove_extent<T>::type;
	using sizeType    = size_t;
	#if _CPP_VERSION_ >= 14
	constexpr
	#endif
	AutoPtr() noexcept:
		_count(new sizeType*(nullptr)),
		_data(nullptr) {
	}
	#if _CPP_VERSION_ >= 14
	constexpr
	#endif
	AutoPtr(T *d) noexcept:
		_count(new sizeType*(new sizeType(1))),
		_data(d) {
	}
	#if _CPP_VERSION_ >= 14
	constexpr
	#endif
	AutoPtr(AutoPtr& r) noexcept:
		_count(r._count),
		_data(r._data) {
		if (*r._count != nullptr)
			++**r._count;
	}
	#if _CPP_VERSION_ >= 14
	constexpr
	#endif
	AutoPtr(AutoPtr&& r) noexcept:
		_count(r._count),
		_data(r._data) {
		if (*r._count != nullptr)
			++**r._count;
		r._data  = nullptr;
		r._count = nullptr;
	}
	constexpr sizeType getCount() const noexcept {
		return **_count;
	}
	constexpr T* getData() const noexcept {
		return _data;
	}
	template <typename U>
	constexpr bool operator==(const AutoPtr<U>& r) const noexcept {
		return (void*)_data == (void*)r._data;
	}
	constexpr bool operator==(void* e) const noexcept {
		return (void*)_data == e;
	}
	elementType& operator[](sizeType in) const noexcept {
		return ((elementType*)_data)[in];
	}
	constexpr elementType& operator*() const noexcept {
		return *_data;
	}
	AutoPtr& operator=(T* d) noexcept {
		if (d != _data) {
			
			if (_data != nullptr and *_count != nullptr) {
				if (**_count == 1) {
					deleteClass()(_data);
					delete *_count;
					delete _count;
					*_count = nullptr; 
				} else {
					--**_count;
				}
			} else if (*_count != nullptr and **_count == 1) {
				delete *_count;
				delete _count;
				*_count = nullptr;
			}
			_data  = d;
			_count = new sizeType*(new sizeType(1));
		}
		return *this;
	}
	AutoPtr& operator=(AutoPtr& r) noexcept {
		if (r._data != _data) {
			if (_data != nullptr and *_count != nullptr) {
				if (**_count == 1) {
					deleteClass()(_data);
					delete *_count;
					delete _count;
					*_count = nullptr;
				} else {
					--**_count;
				}
			} else if (*_count != nullptr and **_count == 1) {
				delete *_count;
				delete _count;
				*_count = nullptr; 
			}
			_data  = r._data;
			_count = r._count;
			if (*r._count != nullptr)
				++**r._count;
		}
		return *this;
	}
	AutoPtr& operator=(AutoPtr&& r) noexcept {
		if (r._data != _data) {
			if (_data != nullptr and *_count != nullptr) {
				if (**_count == 1) {
					deleteClass()(_data);
					delete *_count;
					delete _count;
					*_count = nullptr; 
				} else {
					--**_count;
				}
			} else if (*_count != nullptr and **_count == 1) {
				delete *_count;
				delete _count;
				*_count = nullptr;
			}
			_data  = r._data;
			_count = r._count;
			if (*r._count != nullptr)
				++**r._count;
		}
		return *this;
	}
	T* release() noexcept {
		if (_data != nullptr and *_count != nullptr) {
			T* p = _data;
			_data = nullptr;
			if (**_count == 1) {
				delete *_count;
				delete _count;
				*_count = nullptr;
			}
			return p;
		} else if (*_count != nullptr and **_count == 1) {
			delete *_count;
			delete _count;
			*_count = nullptr;
		}
		return nullptr;
	}
	~AutoPtr() {
		if (_data != nullptr and *_count != nullptr) {
			if (**_count == 1) {
				deleteClass()(_data);
				delete *_count;
				delete _count;
				*_count = nullptr; 
			} else {
				--**_count;
			}
		} else if (*_count != nullptr and **_count == 1) {
			delete *_count;
			delete _count;
			*_count = nullptr;
		}
	}
  private:
	sizeType** _count;
	T* _data;
};

#if _CPP_VERSION_ >= 17
template <template <typename> typename T>
class AutoPtr<void,T> {
};
template <typename T, template <typename> typename U>
class AutoPtr<T[],U> {
};
#else
template <typename T>
class AutoPtr<void,T> {
};
template <typename T, typename U>
class AutoPtr<T[],U> {
};
#endif

#if _CPP_VERSION_ >= 17

template <typename T>
AutoPtr(T*) -> AutoPtr<T>;

template <typename T, template <typename> typename U>
AutoPtr(AutoPtr<T,U>) -> AutoPtr<T,U>;

#endif

#ifdef STD_NAMESPACE
}
#endif

#endif