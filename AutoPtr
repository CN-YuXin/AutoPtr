#include <_TestVersion>

#if !defined(_AUTO_PTR_OF_YX_) && _CPP_VERSION_ != 98
#define _AUTO_PTR_OF_YX_

#include <type_traits>

#ifdef STD_NAMESPACE
namespace STD_NAMESPACE {
#endif

#include <stddef.h>
template <typename U>
struct Delete {
	void operator()(U* d) {
		delete d;
	}
};
template <typename U, size_t S>
struct Delete<U[S]> {
	void operator()(U(*d)[S]) {
		delete [] d;
	}
};
#if _CPP_VERSION_ >= 17
template <typename T, template <typename> typename D = Delete>
#else
template <typename T, typename D = Delete<T>>
#endif
class AutoPtr {
	static inline void addCount(AutoPtr& r) noexcept {
		for (AutoPtr* i = &r;i != nullptr;i = i->_idata->from) {
			++i->_idata->count;
		}
	}
	static inline void remCount(AutoPtr& r) noexcept {
		for (AutoPtr* i = &r;i != nullptr;i = i->_idata->from) {
			--i->_idata->count;
		}
	}
	size_t* _count;
	T* _data;
  public:
	#if _CPP_VERSION_ >= 17
	using deleteClass = D<T>;
	#else
	using deleteClass = D;
	#endif
	using pointToType = T;
	using elementType = typename std::remove_extent<T>::type;
	#if _CPP_VERSION_ >= 14
	constexpr
	#endif
	AutoPtr() noexcept:
		_count(nullptr),
		_data(nullptr) {
	}
	#if _CPP_VERSION_ >= 14
	constexpr
	#endif
	AutoPtr(T *d) noexcept:
		_count(new size_t(1)),
		_data(d) {
	}
	#if _CPP_VERSION_ >= 14
	constexpr
	#endif
	AutoPtr(AutoPtr& r) noexcept:
		_count(r._count),
		_data(r._data) {
		if (r._count != nullptr)
			++*r._count;
	}
	#if _CPP_VERSION_ >= 14
	constexpr
	#endif
	AutoPtr(AutoPtr&& r) noexcept:
		_count(r._count),
		_data(r._data) {
		if (r._count != nullptr)
			++*r._count;
		r._data  = nullptr;
		r._count = nullptr;
	}
	constexpr size_t getCount() const noexcept {
		return *_count;
	}
	constexpr T*const getData() const noexcept {
		return _data;
	}
	template <typename U>
	constexpr bool operator==(const AutoPtr<U>& r) const noexcept {
		return (void*)_data == (void*)r._data;
	}
	constexpr bool operator==(void* e) const noexcept {
		return (void*)_data == e;
	}
	constexpr elementType& operator[](size_t in) const noexcept {
		return _data[in];
	}
	constexpr elementType& operator*() const noexcept {
		return *_data;
	}
	AutoPtr& operator=(T* d) noexcept {
		if (d != _data) {
			if (_data != nullptr and _count != nullptr) {
				if (*_count == 1) {
					deleteClass()(_data);
					if (_count != nullptr)
						delete _count;
				} else {
					--*_count;
				}
			} else if (_count != nullptr) {
				delete _count; 
			}
			_data = d;
			_count = new size_t(1);
		}
		return *this;
	}
	AutoPtr& operator=(AutoPtr& r) noexcept {
		if (r._data != _data) {
			if (_data != nullptr) {
				if (*_count == 1) {
					deleteClass()(_data);
					if (_count != nullptr)
						delete _count;
				} else {
					--*_count;
				}
			} else if (_count != nullptr) {
				delete _count; 
			}
			_data = r._data;
			_count = r._count;
			++*r._count;
		}
		return *this;
	}
	AutoPtr& operator=(AutoPtr&& r) noexcept {
		if (r._data != _data) {
			if (_data != nullptr) {
				if (*_count == 1) {
					deleteClass()(_data);
					if (_count != nullptr)
						delete _count;
				} else {
					--*_count;
				}
			} else if (_count != nullptr) {
				delete _count; 
			}
			_data = r._data;
			_count = r._count;
			++*r._count;
		}
		r._data  = nullptr;
		r._count = nullptr;
		return *this;
	}
	T* release() noexcept {
		if (_data != nullptr) {
			T* p = _data;
			_data = nullptr;
			delete _count;
			_count = nullptr;
			return p;
		} else if (_count != nullptr) {
			delete _count;
			_count = nullptr; 
		}
		return nullptr;
	}
	~AutoPtr() {
		if (_data != nullptr and _count != nullptr) {
			if (*_count == 1) {
				deleteClass()(_data);
				if (_count != nullptr)
					delete _count;
			} else {
				--*_count;
			}
		} else if (_count != nullptr) {
			delete _count; 
		}
	}
};

#if _CPP_VERSION_ >= 17
template <template <typename> typename T>
class AutoPtr<void,T> {
};
template <typename T, template <typename> typename U>
class AutoPtr<T[],U> {
};
#else
template <typename T>
class AutoPtr<void,T> {
};
template <typename T, typename U>
class AutoPtr<T[],U> {
};
#endif

#if _CPP_VERSION_ >= 17

template <typename T>
AutoPtr(T*) -> AutoPtr<T>;

template <typename T>
AutoPtr(AutoPtr<T>) -> AutoPtr<T>;

#endif

#ifdef STD_NAMESPACE
}
#endif

#endif